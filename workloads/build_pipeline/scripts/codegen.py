#!/usr/bin/env python3
"""
Code Generation Script for Build Pipeline Example

Generates Rust source files with configurable problem sizes.
Creates modules with large const arrays to exercise compiler memory usage.

Usage:
    python3 codegen.py --size small --output src
"""

import argparse
import os
import sys
from pathlib import Path


# Problem size configurations
SIZES = {
    'small': {
        'modules': 3,
        'items_per_module': 1000,
        'description': 'Quick demo (~10 MB source, ~100 MB peak memory)'
    },
    'medium': {
        'modules': 5,
        'items_per_module': 5000,
        'description': 'Moderate workload (~50 MB source, ~500 MB peak memory)'
    },
    'large': {
        'modules': 10,
        'items_per_module': 10000,
        'description': 'Stress test (~200 MB source, ~2 GB peak memory)'
    }
}


def generate_module(module_id, items_count, output_dir):
    """Generate a single Rust module with const data and functions."""

    module_name = f"module_{module_id}"
    file_path = output_dir / f"{module_name}.rs"

    print(f"  Generating {module_name}.rs with {items_count} items...")

    with open(file_path, 'w') as f:
        # Module header
        f.write(f"""//! Generated module {module_id}
//! Contains {items_count} data items for compilation stress testing

""")

        # Generate const data array
        f.write(f"/// Large const array for compilation memory testing\n")
        f.write(f"pub const DATA_{module_id}: [u64; {items_count}] = [\n")

        # Generate array contents (deterministic pseudo-random values)
        for i in range(items_count):
            # Simple pseudo-random generation (not cryptographic)
            value = (module_id * 1000000 + i * 997) % (2**32)
            f.write(f"    {value},\n")

        f.write("];\n\n")

        # Generate struct definitions
        f.write(f"""/// Data structure for processing
#[derive(Debug, Clone, Copy)]
pub struct Item {{
    pub id: u64,
    pub value: u64,
    pub checksum: u64,
}}

impl Item {{
    pub fn new(id: u64, value: u64) -> Self {{
        Self {{
            id,
            value,
            checksum: id.wrapping_add(value),
        }}
    }}

    pub fn validate(&self) -> bool {{
        self.checksum == self.id.wrapping_add(self.value)
    }}
}}

""")

        # Generate processing function
        f.write(f"""/// Process all data items in this module
pub fn process() -> u64 {{
    DATA_{module_id}.iter().sum()
}}

/// Create items from const data
pub fn create_items() -> Vec<Item> {{
    DATA_{module_id}
        .iter()
        .enumerate()
        .map(|(i, &value)| Item::new(i as u64, value))
        .collect()
}}

/// Validate all items
pub fn validate_items(items: &[Item]) -> bool {{
    items.iter().all(|item| item.validate())
}}

""")

        # Generate tests (will allocate memory when run)
        f.write(f"""#[cfg(test)]
mod tests {{
    use super::*;

    #[test]
    fn test_process() {{
        let sum = process();
        assert!(sum > 0);
    }}

    #[test]
    fn test_items() {{
        let items = create_items();
        assert_eq!(items.len(), {items_count});
        assert!(validate_items(&items));
    }}
}}
""")


def generate_main(num_modules, output_dir):
    """Generate main.rs that uses all modules."""

    file_path = output_dir / "main.rs"

    print(f"  Generating main.rs...")

    with open(file_path, 'w') as f:
        f.write("""//! Build Pipeline Example - Generated Main Binary
//!
//! This binary is generated by codegen.py and includes multiple modules
//! with large const data structures to exercise compiler memory usage.

""")

        # Module declarations
        for i in range(num_modules):
            f.write(f"mod module_{i};\n")
        f.write("\n")

        # Main function
        f.write("""fn main() {
    println!("Build Pipeline Example - Generated Binary");
    println!();

""")

        # Call each module
        for i in range(num_modules):
            f.write(f"""    println!("Processing module {i}...");
    let sum_{i} = module_{i}::process();
    println!("  Sum: {{}}", sum_{i});
""")

        f.write("""
    println!();
    println!("All modules processed successfully!");
}
""")


def generate_lib(num_modules, output_dir):
    """Generate lib.rs for library support."""

    file_path = output_dir / "lib.rs"

    print(f"  Generating lib.rs...")

    with open(file_path, 'w') as f:
        f.write("""//! Build Pipeline Example - Library
//!
//! Library interface for generated modules.

""")

        # Module declarations
        for i in range(num_modules):
            f.write(f"pub mod module_{i};\n")
        f.write("\n")

        # Library function
        f.write("""/// Process all modules and return total sum
pub fn process_all() -> u64 {
""")

        for i in range(num_modules):
            f.write(f"    let sum_{i} = module_{i}::process();\n")

        f.write("    ")
        for i in range(num_modules):
            if i > 0:
                f.write(" + ")
            f.write(f"sum_{i}")
        f.write("\n}\n")


def main():
    parser = argparse.ArgumentParser(
        description='Generate Rust source code for build pipeline example'
    )
    parser.add_argument(
        '--size',
        choices=['small', 'medium', 'large'],
        default='small',
        help='Problem size (default: small)'
    )
    parser.add_argument(
        '--output',
        type=Path,
        required=True,
        help='Output directory for generated files'
    )

    args = parser.parse_args()

    # Get configuration
    config = SIZES[args.size]

    print("=" * 50)
    print("Code Generation for Build Pipeline Example")
    print("=" * 50)
    print(f"Size: {args.size}")
    print(f"Description: {config['description']}")
    print(f"Modules: {config['modules']}")
    print(f"Items per module: {config['items_per_module']}")
    print()

    # Create output directory
    output_dir = args.output
    output_dir.mkdir(parents=True, exist_ok=True)

    # Generate all modules
    print(f"Generating {config['modules']} modules...")
    for i in range(config['modules']):
        generate_module(i, config['items_per_module'], output_dir)

    # Generate main and lib
    generate_main(config['modules'], output_dir)
    generate_lib(config['modules'], output_dir)

    # Calculate approximate sizes
    source_size_mb = (config['modules'] * config['items_per_module'] * 20) / (1024 * 1024)
    print()
    print(f"✓ Generated {config['modules']} modules")
    print(f"✓ Approximate source size: {source_size_mb:.1f} MB")
    print()
    print("Next: Run 'make build' to compile")


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nInterrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\nError: {e}", file=sys.stderr)
        sys.exit(1)
